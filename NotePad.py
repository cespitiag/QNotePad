# -*- coding: utf-8 -*-
from typing import List, Any
import copy

# Form implementation generated from reading ui file '.\NotePad.ui'
#
# Created by: PyQt5 UI code generator 5.15.10
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

"""
Considerations:

→ Use PlainTextEdit instead of TextEdit, due to when resize it the window becomes slow
"""

from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import QTabWidget, QSizePolicy, QWidget, QLabel, QSystemTrayIcon, QPlainTextEdit, QSizeGrip
from PyQt5.QtGui import QIcon, QFont, QFontDatabase, QKeySequence
from PyQt5.QtCore import Qt, pyqtSignal, QMargins
import os


class Fonts(QFontDatabase):
    """
    This class is created to get the font Data
    @type fontData: It constains the data
    @func getFontsFamilies: it returns the data
    """

    fontData: list[str] | list[Any]

    def __init__(self):
        super().__init__()
        self.fontData = QFontDatabase().families()

    def getFontsFamilies(self) -> Any:
        return self.fontData

class TabsInfo():

    plain_text_widget: QPlainTextEdit | QPlainTextEdit

    def __init__(self, name: str, plain_text_widget: QWidget = None, path: str | None = None,
                 zoom: int = 100, save = False, copy = False, paste = False, cut = False, delete_selection = False):
        """
        This object will incharge to temporary save the tab information
        get the name from the tabFormat
        verify if the path exist

        :param name: The name of the tab
        :param indicator: the indicador on the tab
        :param content: The content inside path
        :param path: The path where the file is localed or will be saved
        :param zoom: The zoom on the path
        :param save : Indicates if the document has been saved or not
        """
        super().__init__()
        self.name: str = name
        self.path: str = path
        self.zoom: str = zoom
        self.save: bool = save
        self.copy: bool = copy
        self.paste: bool = paste
        self.cut : bool = cut
        self.delete_selection = delete_selection
        self.plain_text_widget : QPlainTextEdit = plain_text_widget

    def getTabName(self):
        """
        To obtain the (name) on the tab
        :return: str name
        """
        return self.name

    def getTabPath(self):
        """
        To obtain the (path) on the tab
        :return: str path
        """
        return self.path

    def getTabZoom(self):
        """
        To obtain the (Zoom) on the tab
        :return: str int
        """
        return self.zoom

    def getNameFromPath(self, separator: str = "/", format: str = ".txt") -> str:
        """
        This function will split the path and will take the name of the last position on the path
        give the separator it will take the last number on the path
        as defult there is a separator '/' and the format '.txt'
        you can change the format

        :param str separator : define the separator to split the string on a list
        :param str format : place the format to split the text adequately, by default .txt
        :return: name
        """
        name: str = self.path.split("{}".format(separator))[-1]
        name = name.split("{}".format(format))[0]
        return name

    def pathExists(self):
        """
        This function evaluate is the path exist
        :return: bool
        """
        return os.path.exists(self.path)

class Tab(QTabWidget):

    """
    Tab that crate the widgets and new tabs
    """
    s_noTabs = pyqtSignal(bool)
    s_update_plain_text_edit = pyqtSignal(TabsInfo)
    s_is_the_tab_saved = pyqtSignal(bool)

    tabCounter = 0  # Variable created to control the name on the tabs
    tabNameCounter = -1
    tab_track: list[int, int] = [0, 0]  # list that will sotorage the behaviour
    __enable_tab_track: bool = False  # Tab track mode change the tab behaviour
    last_index_clicked : int = -1 # save the current_index that has been clicked

    def __init__(self):
        """

        :param tabName: Name that control the widget default name
        :param tabCounter: It controls the number of tab created
        :param basename = It is the basename of the tab Untitled
        :param icon = param to that contains the tab's icon
        :param tabIcon = utilize icon, this variable will be use to charge the icon on the tab
        """
        super().__init__()
        # Setting tabWidget
        self.setStyleSheet("QTabWidget {background-color: white}")
        self.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        self.tabBar().setStyleSheet("QTabBar::tab { height: 40px; width: 245px}")  # CSS definition
        self.basename: str = "Untitled"
        self.tabName: str = "{} {}".format(self.basename, self.tabNameCounter)
        self.setAcceptDrops(True)
        self.tabsInfo: dict[int: TabsInfo] = {}
        self.setStyleSheet("")
        self.setTabsClosable(True)  # Do the tab to close
        self.setMovable(True)  # Do the tab Movable
        self.icon: QIcon = QIcon(r"Icons/yellow_note.png")  # "C:\\Users\\cespitia\\Downloads\\svgtopng\\body-text.png"
        self.setTabIcon(0, self.icon)
        self.tab_in_vizualize: int = 0  # This variable is incharge to save the tab to vizualize


        # CONECTING SIGNALS
        self.tabCloseRequested.connect(self._tab_close_request)
        self.currentChanged.connect(self.__current_tab_changed)
        self.tabBarClicked.connect(self.__tab_bar_clicked)

    def _tab_close_request(self, a):

        """
        When press teh x button they send the request to close it
        it change dinamically the id and the paths, when we change the tabs
        emmit the signals when there is no tabs
        """
        if not self.tabsInfo[a].save: # This funcion will evaluate if the tab has been save
            self.s_is_the_tab_saved.emit(False)
            return


        self.tabCounter -= 1

        if self.count() - 1 == 1:
            print("Entre")
            self.last_index_clicked = -1
            self.tab_track = [0, 0]

        if (self.count() - 1) > 0 and not self.is_enable_tab_track():

            # When the tab closes it reorganize the dictionary that contains the elements to be according witht he tab
            sorted(self.tabsInfo.items())  # Sort the dictionary
            self.__reorganaize_tab_info_dict(item_to_delete=a)  # Delete and reincorporte the items in tabsInfo
            self.__reorganaize_tab_viwer_standard_mode(item_to_delete=a)  # Define with would be the next current_index
            self.removeTab(a)  # Remove the tab

        elif (self.count() - 1) > 0 and self.is_enable_tab_track():
            # Reorganaize the tabs
            # Reorganaize the tabs info
            # Delete the respective tab

            sorted(self.tabsInfo.items())  # Sort the dictionary

            if self.__reorganaize_tab_items_with_track_mode(item_to_delete= a):
                self.tab_in_vizualize = self.currentIndex() - 1 if self.currentIndex() - 1 > 0 else 0
                self.tab_track[0] = self.tab_track[0] - 1 if self.tab_track[0] - 1 > 0 else 0

            self.__reorganaize_tab_info_dict(a)
            self.removeTab(a)

        else:
            self.s_noTabs.emit(True)  # emmit the signal if there is no tab

        for i, j in self.tabsInfo.items():
            print("en request close{} {}".format(i, j.name))

    def __reorganaize_tab_info_dict(self, item_to_delete):

        aux = self.tabsInfo.copy()
        for i in range(item_to_delete, len(aux) - 1):
            # Deleting the components in the dictionary
            del self.tabsInfo[i]

        for i in range(item_to_delete, len(aux) - 1):
            # Reestablishing the tabs info
            self.tabsInfo[i] = aux[i + 1]

        self.tabsInfo.pop(len(self.tabsInfo) - 1)  # Delete the extra item included

        sorted(self.tabsInfo.items())

    def __reorganaize_tab_viwer_standard_mode(self, item_to_delete: int = None):
        """
        this function will predict which would be the next item to visualize so one it remove the tab
        There would not create a movement

        :param item_to_delete: the item to expected delete
        :return: item to delete
        """
        visor = self.tab_in_vizualize
        last_item = self.count() - 1 # 4 tabs | 3 tab | 2 tab

        if visor == item_to_delete and visor == 0:
            # The visualization will change poss -1  but if is 0 it would be 0
            self.tab_in_vizualize = 0

        elif item_to_delete < visor:
            self.tab_in_vizualize = visor - 1

        elif item_to_delete == last_item:
            self.tab_in_vizualize = last_item - 1

        elif item_to_delete == visor:
            self.tab_in_vizualize = visor

    def __reorganaize_tab_items_with_track_mode(self, item_to_delete):
        """
        This funtion will define who will be the next part to vizualize, the new tab next to view and the item to delete

        :param item_to_delete: item that will be deleted
        """
        visor = self.currentIndex()
        last_item = self.count() -1

        """
        POSSITION_BY_DEFAULT = last_item -1
        
        SCENARIO1: When the user delete the nex tab to visulize (NTV), Who will be the next tab?
        
        ---- + POSITION = is the last item?
        ---------- + YES = Before is the visor?
        ---------------- + YES = (NVT) will be the visor - 1
        ---------------- + NO  = (NVT) will be POSITION_BY_DEFAULT
        ---------- + NO  = (NVT) will be POSSITION_BY_DEFAULT
        
           
        
        SCENARIO2: When the user delete the tab the user is visualizing, where is the (NTV)
        
        --- + SUBSENARIO 2 : When the visor < (NTV)
        --- + SUBSENARIO 3 : When the visor > (NTV)  629erinearndt@gmail.com
        
        SENARIO3: When the user delete a different tab
        
        --- + SUBSENARIO 5 : When the visor < item_to delete and (NTV) < item_to_delete
        --- + SUBSENARIO 6 : When the visor < item_to_delte and (NTV) > item_to_delte  629erinearndt@gmail.com
        --- + SUBSENARIO 7 : When the visor < item_to_delte and (NTV) < item_to_delte  629erinearndt@gmail.com
        --- + SUBSENARIO 8 : When the visor > item_to_delte and (NTV) > item_to_delte  629erinearndt@gmail.com
        
        
        
        """

        POSITION_BY_DEFAULT : int = last_item

        scenario1 : bool  = item_to_delete == self.tab_track[0]
        scenario2 : bool = item_to_delete == visor
        scenario3 : bool = item_to_delete != visor and item_to_delete != self.tab_track[0]

        subcenario1 : bool = self.tab_track[0] == last_item and visor == self.tab_track[0] - 1

        subcenario2 : bool = visor == last_item and self.tab_track[0] == visor - 1
        subcenario3 : bool = self.tab_track[0] == last_item
        subcenario4 : bool = visor == self.tab_track[0] - 1 and self.tab_track[0] == last_item
        subcenario5 : bool = visor > self.tab_track[0]
        subcenario6 : bool = visor < self.tab_track[0]

        subcenario7 : bool = item_to_delete > visor and item_to_delete < self.tab_track[0]
        subcenario8 : bool = item_to_delete < visor and item_to_delete > self.tab_track[0]
        subcenario9 : bool = item_to_delete < visor and item_to_delete < self.tab_track[0]
        subcenario10 : bool = item_to_delete > visor and item_to_delete > self.tab_track[0]

        if visor == self.tab_track[0]:
            self.tab_track[0] -= 1

        if self.last_index_clicked == item_to_delete:
            self.last_index_clicked = self.tab_track[1]

        if scenario1: # (NTV) next tab to view

            if visor == last_item:
                self.tab_track[0] = visor - 1
                return 1 # Return 1 means that it will be delete if a before item and the current_index clicked shoud be modified

            if subcenario1:
                self.tab_track[0] = visor - 1
                self.tab_track[1] = self.currentIndex()
            elif subcenario4:
                self.tab_in_vizualize = visor - 1
                self.tab_track[0] = POSITION_BY_DEFAULT - 1
                self.tab_track[1] = self.tab_in_vizualize
            elif subcenario5:
                self.tab_track[0] = POSITION_BY_DEFAULT - 1
                self.tab_track[1] = self.currentIndex()

        elif scenario2: # The visor will change

            if subcenario2:

                visor = self.tab_track[0]
                self.tab_track[0] = visor - 1 if visor - 1 >= 0 else 0
                self.tab_in_vizualize = visor
                self.setCurrentIndex(visor)
                self.tab_track[1] = self.tab_in_vizualize
                self.last_index_clicked = visor

            elif subcenario3:
                visor = self.tab_track[0]
                self.tab_track[0]  = POSITION_BY_DEFAULT
                self.tab_in_vizualize = visor
                self.setCurrentIndex(visor)
                print(self.tab_track)
                self.last_index_clicked = visor - 1
                return 1

            elif subcenario4:
                visor = self.tab_track[0]
                self.tab_track[0] = visor - 1 if visor - 1 >= 0 else 0
                self.tab_in_vizualize = visor
                self.tab_track[1] = self.tab_in_vizualize
                self.last_index_clicked = visor - 1


            elif subcenario5:
                visor = self.tab_track[0]
                self.tab_track[0] = POSITION_BY_DEFAULT - 1 if POSITION_BY_DEFAULT - 1 >= 0 else 0
                self.tab_in_vizualize = visor
                self.setCurrentIndex(visor)
                self.tab_track[1] = self.tab_in_vizualize
                self.last_index_clicked = visor

            elif subcenario6: # OK
                # We need to rest 1 position due to if visor < that records
                # It will decrement the number
                visor = self.tab_track[0]
                self.tab_track[0] = POSITION_BY_DEFAULT
                self.tab_in_vizualize = visor
                self.setCurrentIndex(visor)
                self.tab_track[1] = self.tab_in_vizualize
                self.last_index_clicked = visor - 1
                return 1

        elif scenario3:

            if subcenario7:
                # self.tab_track[0] -= self.tab_track[0]
                self.tab_track[0] -= 1
            elif subcenario8:
                self.tab_in_vizualize = visor - 1
                self.tab_track[1] = self.tab_in_vizualize
            elif subcenario9:
                self.tab_track[0] -= 1
                self.tab_in_vizualize = visor - 1
                self.tab_track[1] = self.tab_in_vizualize

            elif subcenario10:
                pass
        else:
            return 0
        print(self.tab_track)
        return 0

    def addTab(self, widget: QWidget = None, name: str = None, path: str | None = None):

        """
        This funcion is an extension of addTab this funcion handle the counter tab an control the name of the tab
        @type widget: you can select the widget inside the tab
        @type name: you can choose the name
        @return This function does not return any value
        """

        if name == None:
            self.tabCounter += 1
            self.tabNameCounter += 1
            self.tabName = f"{self.basename} {self.tabNameCounter}"
        else:
            self.tabCounter += 1
            self.tabName = name

        self.plainTextEditWidget : QPlainTextEdit = self.__creating_plain_text_edit() if widget == None else widget  # Crea un line edit si no esta definido

        super().addTab(self.plainTextEditWidget, self.icon, self.tabName)

        self.tab_in_vizualize = self.count() - 1  # When create a tab the clicked indicator is the same that the new one
        self.objectTabInfo = TabsInfo(self.tabName, self.plainTextEditWidget,
                                      path, save = True)  # Create a tabInfo class to get the information

        self.tabsInfo[self.count() - 1] = self.objectTabInfo

        self.setCurrentIndex(self.count() - 1)
        if self.is_enable_tab_track():
            # if the feature is activated,  update the tabs list recovery in the current possition
            self.__update_tab_track_by_adding_new_tab()
            print(f"IN ADD TAB SELF TRACK {self.tab_track}")

        print("in addtab: --")

        for index, object in self.tabsInfo.items():
            print(f"index : {index} name: {object.name}")

    def adddres_in_tab_exist(self, addressToSearch: str, tabs: 'TabsInfo' = None):
        """
        This funtion is use in order to find if an address exits
        if it does not exist return -1
        :param addressToSearch:
        :return:
        """
        tabs = self.tabsInfo if tabs == None else tabs

        for index, obj in tabs.items():
            if addressToSearch == obj.path:
                return index

        return -1

    def __creating_plain_text_edit(self) -> QPlainTextEdit:

        """
        Private function that creates the predeterminate lineEdit to the Notepad
        To modify the widget refer to this fuction to reply to all the notepads
        """
        # self.textEdit = QtWidgets.QTextEdit()
        plaintextEdit = QtWidgets.QPlainTextEdit()

        # This line define the style when a plainText widget is created
        style = """
            QPlainTextEdit{
                background-color: white;
                border: 0px solid withe;
                padding: 10px;
            }
            QPlainTextEdit:focus {
                border: 0px solid withe;
                outline : none
            }
        """

        font = QFont()
        font.setPointSizeF(10)
        font.setFamily("Lucida Console")
        plaintextEdit.setFont(font)
        # self.textEdit.setStyleSheet("QTextEdit {padding : 30px; background-color : white}")
        plaintextEdit.setStyleSheet(style)  # This code works to dont higlith

        return plaintextEdit
    def __current_tab_changed(self, poss):
        """
        Detect with the tab has been changed and reorganaize the tabs
        :param poss:
        :return:
        """
        print(f"POSS AT THE BEGGINING = {poss}, print self.__tab_track [0] {self.tab_track[0]}")

        NOTENABLE = 0  # The tabTrack mode if off
        ENABLE = 1  # The tabTrack mode is on
        initial_movement = poss - self.tab_in_vizualize

        if not self.is_enable_tab_track():

            self.__determinate_tab_movement(NOTENABLE, poss, initial_movement)

        elif self.is_enable_tab_track():
            self.__determinate_tab_movement(ENABLE, poss, initial_movement)

        if self.tabsInfo != {}:
            """
            When the tab is clicked need to send the widget
            """
            self.s_update_plain_text_edit.emit(self.tabsInfo[poss])

    def __determinate_tab_movement(self, ENABLE: int, poss: int, movement: int)  -> None:

        """
        When the tab Changes it determinates if the tab is in movement how to re-organaize the other tabs
        if the tab track is able this funtion will help to modify the behaviour
        :param ENABLE: if the tab tack is on or off
        :param poss: the current possition
        :param movement: 1 says that it is possitive -1 says that it is negative
        :var aux : it is a copy of the self.tabInfo
        """

        aux = self.tabsInfo.copy()  # made a copy of tabsInfo

        def organaize_positive_movement(aux: dict[int, TabsInfo]) -> None:
            # [tab0 | hi] , [tab1 | ho] ->(func) -> [tab0 | ho] , [tab 1 | hi]

            self.tabsInfo[poss - 1], self.tabsInfo[poss] = aux[poss], aux[poss - 1]
            sorted(self.tabsInfo.items())

            for i, j in self.tabsInfo.items():
                print(i, ' ', j.name)

            self.tab_in_vizualize = poss  # update that the current_index clicked is the tab we are
            self.last_index_clicked = poss # The last tab to be connected when add a new tab
            self.s_update_plain_text_edit.emit(self.tabsInfo[poss])

        def organize_negative_movement(aux: dict[int, TabsInfo]) -> None:
            # [tab0 | hi] , [tab1 | ho] <-(func) <- [tab0 | ho] , [tab 1 | hi]

            self.tabsInfo[poss + 1], self.tabsInfo[poss] = aux[poss], aux[poss + 1]
            sorted(self.tabsInfo.items())
            for i, j in self.tabsInfo.items():
                print(i, ' ', j.name)

            self.tab_in_vizualize = poss  # update that the current_index clicked is the tab we are
            self.last_index_clicked = poss # The last tab to be connected when add a new tab
            self.s_update_plain_text_edit.emit(self.tabsInfo[poss])


        def organaize_track_index_movement(movement : int = 0):

            if poss == self.tab_track[0] and movement == 1:
                self.tab_track[0] = self.tab_track[0] - 1

            elif poss == self.tab_track[0] and movement == -1:
                self.tab_track[0] = self.tab_track[0] + 1

            else:
                pass


        match ENABLE, movement:

            case 0, 1:  # Not track Enable positive movement
                organaize_positive_movement(aux=aux)  # Function to organaize the self.tabsInfo ok

            case 0, -1:  # Not track enable negative movement

                organize_negative_movement(aux=aux)  # Funtion to organaize the self.tabsInfo ok

            case 1, 1:
                self.tab_track[1] = poss
                organaize_positive_movement(aux = aux)
                organaize_track_index_movement(movement = movement)

                # raise NotImplemented("case 1,1 does not have logic code")
            case 1, -1:
                self.tab_track[1] = poss
                organize_negative_movement(aux = aux)
                organaize_track_index_movement(movement = movement)


    def __update_tab_track_by_click(self, tab: int):
        """
        This function is created with user wants to change the tab bechaviour, save the tab where te customer were
        and the current tab
        :param tab: the current tab
        :return: if the tab has been clicked
        """
        if tab != self.tab_track[1]:
            # To Avoid when the current tab being clicked several times
            self.tab_track[0], self.tab_track[1] = self.tab_track[1], tab  # Exchange the value
            self.last_index_clicked = tab

            print(f"NOW {self.tab_track}")


        elif tab == self.tab_track[1]: # It means there are no another tab to go back
            pass

            # self.tab_track[0] = self.tab_track[1] - 1 if tab != 0 else 0

        print(f"SELF TAB TACK {self.tab_track}")

    def __update_tab_track_by_movement(self, previous: int = 0, current: int = 0):

        if self.tab_track == [0, 0]:
            self.tab_track[0], self.tab_track[1] = self.count() - 1, self.currentIndex() # the last and the current

    def __update_tab_track_by_adding_new_tab(self):

        if self.last_index_clicked == -1:
            self.tab_track[0] = self.currentIndex() - 1 if self.currentIndex() - 1 >= 0 else 0
            self.tab_track[1] =  self.currentIndex()

        else:
            self.tab_track[0], self.tab_track[1] = self.last_index_clicked, self.currentIndex()

    def is_enable_tab_track(self) -> bool:
        """
        Return valur if the enable tab track funciton is activated
        :return:
        """
        return self.__enable_tab_track

    def set_enable_tab_track(self, value: bool):
        """
        Modify the enale tab track
        :param value:
        :return:
        """
        assert isinstance(value, bool), "It is not a boolean value"
        self.__enable_tab_track = value

        if value:
            self.tab_track[1] = self.currentIndex()
            self.last_index_clicked = self.currentIndex() if self.currentIndex() != 0 else - 1 # to start the current_index clicked
        else:
            self.tab_track: list [int,int] = [0, 0]

    def __tab_bar_clicked(self, poss):
        """
        it detects when the tabBar is clicked
        save the old tab clicked and the new one
        :param poss:
        :return:
        """
        self.tab_in_vizualize = poss

        if self.is_enable_tab_track():
            # if enable it started to update it the old and the current
            self.__update_tab_track_by_click(poss)


        self.s_update_plain_text_edit.emit(self.tabsInfo[poss])

class Ui_MainWindow(object):

    def setupUi(self, MainWindow):

        def close_():
            """
            this internal window is becasue the variable is not accesible
            for that reason we are cosing inside the application
            """
            MainWindow.close()

        MainWindow.setObjectName("MainWindow")
        MainWindow.setWindowIcon(QIcon(r"Icons/Main_logo.png"))

        MainWindow.resize(963, 698) # Initialize with resize
        margins = QMargins(0, 0, 0, 0)  # setting the margins to don't shoe margins

        self.labelList = [] # will contain the labels on the list

        # Tray icon
        self.tray_icon = QSystemTrayIcon()
        self.tray_icon.setIcon(QIcon(r"Icons/Main_logo.png"))

        # Defined the central widget to put my widgets
        self.centralwidget = QtWidgets.QWidget(MainWindow) # Define the widget
        self.centralwidget.setContentsMargins(margins)
        self.centralwidget.setObjectName("centralwidget")
        MainWindow.setCentralWidget(self.centralwidget)

        # Define the chorizontal Layout
        self.horizontalLayout = QtWidgets.QHBoxLayout(self.centralwidget) # Horizontal layout, parent central widget
        self.horizontalLayout.setContentsMargins(margins)
        self.horizontalLayout.setObjectName("horizontalLayout")


        self.widget = QtWidgets.QWidget(self.centralwidget) #  widget container has parent central widget
        self.widget.setObjectName("widget")

        self.verticalLayout = QtWidgets.QVBoxLayout(self.widget)
        self.verticalLayout.setContentsMargins(margins)
        self.verticalLayout.setObjectName("verticalLayout")

        # Defining the TabWidget over this Widget we are going to do the notebook
        self.tabWidget = Tab()
        self.tabWidget.s_noTabs.connect(close_)  # Conectada a una funcion interna de la función
        self.tabWidget.setObjectName("tabWidget")
        self.tabWidget.addTab()

        # Creating Vertical layout
        self.verticalLayout.addWidget(self.tabWidget)
        self.horizontalLayout.addWidget(self.widget) # Give the space to display the tabs

        # Here is the MenuBar and the rest of the QActions
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 963, 26))
        self.menubar.setObjectName("menubar")
        self.menuFile = QtWidgets.QMenu(self.menubar)
        self.menuFile.setObjectName("menuFile")
        self.menuEdit = QtWidgets.QMenu(self.menubar)
        self.menuEdit.setObjectName("menuEdit")
        self.menuView = QtWidgets.QMenu(self.menubar)
        self.menuView.setObjectName("menuView")
        self.menuZoom = QtWidgets.QMenu(self.menuView)
        self.menuZoom.setObjectName("menuZoom")
        self.menuTrackMode = self.menubar.addMenu("&Track Mode")
        self.menuTrackMode.setObjectName("menuTrackMode")
        self.menuHelp =self.menubar.addMenu("&Help")
        self.menuHelp.setObjectName("menuHelp")
        MainWindow.setMenuBar(self.menubar)

        # Statrus bar
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        # Craeting the Label tabs
        self.statusLabel_1 = QLabel()
        self.statusLabel_2 = QLabel()
        self.statusLabel_3 = QLabel()
        self.statusLabel_4 = QLabel()
        self.statusLabel_5 = QLabel()

        # Giving name on the list to work individualy
        self.statusLabel_1.setText("None1")  # Label for the colum| rows
        self.statusLabel_1.setMaximumWidth(200)
        self.statusLabel_1.setMinimumWidth(150)
        self.statusLabel_1.setSizePolicy(QSizePolicy.Policy.MinimumExpanding, QSizePolicy.Policy.Fixed)

        self.statusLabel_2.setText("None2")  # Label for the total Characters
        self.statusLabel_2.setMinimumWidth(300)
        self.statusLabel_2.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)

        self.statusLabel_3.setText("None3")  # Label for the Zoom percentage
        self.statusLabel_3.setMaximumWidth(150)
        self.statusLabel_3.setMinimumWidth(50)
        self.statusLabel_3.setSizePolicy(QSizePolicy.Policy.MinimumExpanding, QSizePolicy.Policy.Fixed)

        self.statusLabel_4.setText("None4")  # Label for the operative system
        self.statusLabel_4.setMaximumWidth(150)
        self.statusLabel_4.setMinimumWidth(50)
        self.statusLabel_4.setSizePolicy(QSizePolicy.Policy.MinimumExpanding, QSizePolicy.Policy.Fixed)

        self.statusLabel_5.setText("None5")  # Label for the codifications characters unicode
        self.statusLabel_5.setMaximumWidth(100)
        self.statusLabel_5.setMinimumWidth(50)
        self.statusLabel_5.setSizePolicy(QSizePolicy.Policy.MinimumExpanding, QSizePolicy.Policy.Fixed)

        # Append the label to a list in order to work with them
        self.statusbar.addWidget(self.statusLabel_1)
        self.statusbar.addWidget(self.statusLabel_2, stretch=1) # If you want to center it place  1
        self.statusbar.addWidget(self.statusLabel_3)
        self.statusbar.addWidget(self.statusLabel_4)
        self.statusbar.addWidget(self.statusLabel_5)

        self.actionNew_Tab = QtWidgets.QAction(MainWindow)
        self.actionNew_Tab.setShortcutContext(QtCore.Qt.WindowShortcut)
        self.actionNew_Tab.setShortcutVisibleInContextMenu(False)
        self.actionNew_Tab.setObjectName("actionNew_Tab")
        self.actionNew_Tab.setIcon(QIcon(r"Icons/new_tab.png"))
        self.actionNew_Tab.setShortcut(QKeySequence("Ctrl+N"))
        self.actionNew_Window = QtWidgets.QAction(MainWindow)
        self.actionNew_Window.setShortcutVisibleInContextMenu(False)
        self.actionNew_Window.setObjectName("actionNew_Window")
        self.actionOpen = QtWidgets.QAction(MainWindow)
        self.actionOpen.setObjectName("actionOpen")
        self.actionOpen.setIcon(QIcon(r"Icons/openFile.png"))
        self.actionOpen.setShortcut(QKeySequence("Ctrl+O"))
        self.actionSave = QtWidgets.QAction(MainWindow)
        self.actionSave.setObjectName("actionSave")
        self.actionSave.setIcon(QIcon("Icons/save.png"))
        self.actionSave.setShortcut(QKeySequence("Ctrl+S"))
        self.actionSave_as = QtWidgets.QAction(MainWindow)
        self.actionSave_as.setObjectName("actionSave_as")
        self.actionSave_as.setIcon(QIcon("Icons/save_as.png"))
        self.actionSave_as.setShortcut(QKeySequence("Shift+Ctrl+S"))
        self.actionSave_all = QtWidgets.QAction(MainWindow)
        self.actionSave_all.setObjectName("actionSave_all")
        self.actionSave_all_2 = QtWidgets.QAction(MainWindow)
        self.actionSave_all_2.setObjectName("actionSave_all_2")
        self.actionPage_preview = QtWidgets.QAction(MainWindow)
        self.actionPage_preview.setObjectName("actionPage_preview")
        self.actionPrint = QtWidgets.QAction(MainWindow)
        self.actionPrint.setObjectName("actionPrint")
        self.actionPrint.setIcon(QIcon("Icons/print.png"))
        self.actionPrint.setShortcut("Ctrl+P")
        self.actionClose_Tab = QtWidgets.QAction(MainWindow)
        self.actionClose_Tab.setObjectName("actionClose_Tab")
        self.actionClose_Tab.setIcon(QIcon("Icons/closeTab.png"))
        self.actionClose_Tab.setShortcut("Ctrl+W")
        self.actionClose_Window = QtWidgets.QAction(MainWindow)
        self.actionClose_Window.setShortcut("Shift+Ctrl+W")
        self.actionClose_Window.setObjectName("actionClose_Window")
        self.actionExit = QtWidgets.QAction(MainWindow)
        self.actionExit.setObjectName("actionExit")
        self.actionUndo = QtWidgets.QAction(MainWindow)
        self.actionUndo.setObjectName("actionUndo")
        self.actionUndo.setIcon(QIcon("Icons/undo.png"))
        self.actionUndo.setShortcut("Ctrl+Z")
        self.actionUndo.setEnabled(False)
        self.actionRedo = QtWidgets.QAction(MainWindow)
        self.actionRedo.setObjectName("actionRedo")
        self.actionRedo.setText("Redo")
        self.actionRedo.setEnabled(False)
        self.actionRedo.setShortcut("Ctrl+Y")
        self.actionRedo.setIcon(QIcon("Icons/redo.png"))
        self.actionCut = QtWidgets.QAction(MainWindow)
        self.actionCut.setObjectName("actionCut")
        self.actionCut.setShortcut(QKeySequence("Ctrl+X"))
        self.actionCut.setIcon(QIcon("Icons/cut.png"))
        self.actionCopy = QtWidgets.QAction(MainWindow)
        self.actionCopy.setObjectName("actionCopy")
        self.actionCopy.setIcon(QIcon("Icons/icons8-copy-94.png"))
        self.actionCopy.setShortcut("Ctrl+C")
        self.actionPaste = QtWidgets.QAction(MainWindow)
        self.actionPaste.setObjectName("actionPaste")
        self.actionPaste.setIcon(QIcon("Icons/paste.png"))
        self.actionPaste.setShortcut("Ctrl+V")
        self.actionFind = QtWidgets.QAction(MainWindow)
        self.actionFind.setObjectName("actionFind")
        self.actionFind_next = QtWidgets.QAction(MainWindow)
        self.actionFind_next.setObjectName("actionFind_next")
        self.actionFind_previous = QtWidgets.QAction(MainWindow)
        self.actionFind_previous.setObjectName("actionFind_previous")
        self.actionReplace = QtWidgets.QAction(MainWindow)
        self.actionReplace.setObjectName("actionReplace")
        self.actionGo_to = QtWidgets.QAction(MainWindow)
        self.actionGo_to.setObjectName("actionGo_to")
        self.actionDelete_2 = QtWidgets.QAction(MainWindow)
        self.actionDelete_2.setObjectName("actionDelete_2")
        self.actionDelete_2.setIcon(QIcon("Icons/clear.png"))
        self.actionSelect_all = QtWidgets.QAction(MainWindow)
        self.actionSelect_all.setObjectName("actionSelect_all")
        self.actionTime_Date = QtWidgets.QAction(MainWindow)
        self.actionTime_Date.setObjectName("actionTime_Date")
        self.actionTime_Date.setIcon(QIcon("Icons/time.png"))
        self.actionFont = QtWidgets.QAction(MainWindow)
        self.actionFont.setObjectName("actionFont")
        self.actionZoom_in = QtWidgets.QAction(MainWindow)
        self.actionZoom_in.setShortcut(QKeySequence("Ctrl++"))
        self.actionZoom_in.setIcon(QIcon(r"Icons\zoom-in.png"))
        self.actionZoom_in.setObjectName("actionZoom_in")
        self.actionZoom_out = QtWidgets.QAction(MainWindow)
        self.actionZoom_out.setShortcut(QKeySequence("Ctrl+-"))
        self.actionZoom_out.setIcon(QIcon(r"Icons\zoom-out.png"))
        self.actionZoom_out.setObjectName("actionZoom_out")
        self.actionStatus_bar = QtWidgets.QAction(MainWindow)
        self.actionStatus_bar.setObjectName("actionStatus_bar")
        self.actionStatus_bar.setCheckable(True)
        self.actionStatus_bar.setChecked(True)
        self.actionWord_wrap = QtWidgets.QAction(MainWindow)
        self.actionWord_wrap.setObjectName("actionWord_wrap")
        self.actionEnableTrackMode = QtWidgets.QAction(MainWindow)
        self.actionEnableTrackMode.setCheckable(True)
        self.actionEnableTrackMode.setObjectName("actionTrack_mode")
        self.actionEnableTrackMode.setShortcut("Ctrl+T")
        self.actionAbout = QtWidgets.QAction(MainWindow)
        self.actionAbout.setIcon(QIcon("Icons/about.png"))



        self.menuFile.addAction(self.actionNew_Tab)
        self.menuFile.addAction(self.actionNew_Window)
        self.menuFile.addAction(self.actionOpen)
        self.menuFile.addSeparator()
        self.menuFile.addAction(self.actionSave)
        self.menuFile.addAction(self.actionSave_as)
        self.menuFile.addAction(self.actionSave_all_2)
        self.menuFile.addSeparator()
        self.menuFile.addAction(self.actionPage_preview)
        self.menuFile.addAction(self.actionPrint)
        self.menuFile.addSeparator()
        self.menuFile.addAction(self.actionClose_Tab)
        self.menuFile.addAction(self.actionClose_Window)
        self.menuFile.addAction(self.actionExit)
        self.menuEdit.addAction(self.actionUndo)
        self.menuEdit.addSeparator()
        self.menuEdit.addAction(self.actionRedo)
        self.menuEdit.addSeparator()
        self.menuEdit.addAction(self.actionCut)
        self.menuEdit.addAction(self.actionCopy)
        self.menuEdit.addAction(self.actionPaste)
        self.menuEdit.addAction(self.actionDelete_2)
        self.menuEdit.addSeparator()
        self.menuEdit.addAction(self.actionFind)
        self.menuEdit.addAction(self.actionFind_next)
        self.menuEdit.addAction(self.actionFind_previous)
        self.menuEdit.addAction(self.actionReplace)
        self.menuEdit.addAction(self.actionGo_to)
        self.menuEdit.addAction(self.actionSelect_all)
        self.menuEdit.addAction(self.actionTime_Date)
        self.menuEdit.addAction(self.actionFont)
        self.menuZoom.addAction(self.actionZoom_in)
        self.menuZoom.addAction(self.actionZoom_out)
        self.menuView.addAction(self.menuZoom.menuAction())
        self.menuView.addAction(self.actionStatus_bar)
        self.menuView.addAction(self.actionWord_wrap)
        self.menuTrackMode.addAction(self.actionEnableTrackMode)
        self.menuHelp.addAction(self.actionAbout)
        self.menubar.addAction(self.menuFile.menuAction())
        self.menubar.addAction(self.menuEdit.menuAction())
        self.menubar.addAction(self.menuView.menuAction())
        self.menubar.addAction(self.menuTrackMode.menuAction())
        self.menubar.addAction(self.menuHelp.menuAction())

        self.retranslateUi(MainWindow)
        self.tabWidget.setCurrentIndex(0)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "QNotePad")) # Define the window Title
        self.menuFile.setTitle(_translate("MainWindow", "File"))
        self.menuEdit.setTitle(_translate("MainWindow", "Edit"))
        self.menuView.setTitle(_translate("MainWindow", "View"))
        self.menuZoom.setTitle(_translate("MainWindow", "Zoom"))
        self.actionNew_Tab.setText(_translate("MainWindow", "New Tab"))
        self.actionNew_Window.setText(_translate("MainWindow", "New Window"))
        self.actionOpen.setText(_translate("MainWindow", "Open"))
        self.actionSave.setText(_translate("MainWindow", "Save"))
        self.actionSave_as.setText(_translate("MainWindow", "Save as "))
        self.actionSave_all.setText(_translate("MainWindow", "Save all"))
        self.actionSave_all_2.setText(_translate("MainWindow", "Save all"))
        self.actionPage_preview.setText(_translate("MainWindow", "Page Preview"))
        self.actionPrint.setText(_translate("MainWindow", "Print"))
        self.actionClose_Tab.setText(_translate("MainWindow", "Close Tab"))
        self.actionClose_Window.setText(_translate("MainWindow", "Close Window"))
        self.actionExit.setText(_translate("MainWindow", "Exit"))
        self.actionUndo.setText(_translate("MainWindow", "Undo"))
        self.actionCut.setText(_translate("MainWindow", "Cut"))
        self.actionCopy.setText(_translate("MainWindow", "Copy"))
        self.actionPaste.setText(_translate("MainWindow", "Paste"))
        self.actionFind.setText(_translate("MainWindow", "Find"))
        self.actionFind_next.setText(_translate("MainWindow", "Find next"))
        self.actionFind_previous.setText(_translate("MainWindow", "Find previous"))
        self.actionReplace.setText(_translate("MainWindow", "Replace"))
        self.actionGo_to.setText(_translate("MainWindow", "Go to"))
        self.actionDelete_2.setText(_translate("MainWindow", "Delete"))
        self.actionSelect_all.setText(_translate("MainWindow", "Select all"))
        self.actionTime_Date.setText(_translate("MainWindow", "Time/Date"))
        self.actionFont.setText(_translate("MainWindow", "Font"))
        self.actionZoom_in.setText(_translate("MainWindow", "Zoom in"))
        self.actionZoom_out.setText(_translate("MainWindow", "Zoom out"))
        self.actionStatus_bar.setText(_translate("MainWindow", "Status bar"))
        self.actionWord_wrap.setText(_translate("MainWindow", "Word wrap"))
        self.actionEnableTrackMode.setText("Enable Track Mode")
        self.actionAbout.setText("About this program")


if __name__ == "__main__":
    import sys

    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())
